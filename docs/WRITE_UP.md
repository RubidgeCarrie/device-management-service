# Architecture Decision Record and Challenges

# Database choice
Given the nature of the endpoints they could have been implemented on a NoSQL database, such as MongoDB where the different status columns could have sat in a single database without any problems.

However, non-relational databases are problematic if access patterns change and are not pre-defined. Therefore Relational databases would give more flexibility for device management where the queries patterns are might be changing as the company scaled and new analytics are needed. 
Relational databases are also great for ACID transactions, for tracking the status of IoT devices we would probably want ACID transactions.

## Database Schema:

 **device_register**:  central store of all device types including summaries and registering a unique id across devices.

Each device type then has its own table (e.g: **thermostats** , **security_cameras**) for recording status/configuration history:

These tables store all status/configuration updates and can be queried for the latest byt `timestamp`.

 In practice we would have a cron job to remove/ archive historic data. 
![DatabaseImage](/docs/device_management_database.png)

# API server

I chose to use python since I had been wanting an opportunity to try FastAPI and `SQLAlchemy`. I have previously made the decision to avoid ORM's and use "raw" SQL and our own schema migration system using custom resources in AWS instead of leaning on something a package like `alembic` from `SQLAlchemy`.

If I were to use  `Node.js` I would have gone with [Express](https://expressjs.com/) for the API's. 

I wanted to try see how these tools worked together and autogenerated swagger documentation. 

# Challenges

It was great getting a chance to work with FastAPI but it definitely had some limitations and difficulties. 

- UUIDS don't work natively with FastAPI and pydantic model validation  so I ended up using an autogenerated id for now but in a production system I would use UUID
- Enum's don't work nicely with SQLAlchemy out of the box
- Naming: Naming between pydantic schemas, the SQlAlechemy ORM and identifying post (without ids) and responses (same schema with ids) writing readable code with easy to follow naming conventions was a challenge

# Future updates

1. Add authentication
2. Use Alembic db migrations -> have some form of schema migration automation
3. Asynchronous requests rather than synchronous requests -> handle concurrent requests better
4. Crud operations in `src/app/crud` are repetitive, I would neaten up these to make use of a single common query.

# Path to Production

The API Server is running in a container making it easy to host on an EC2 using a 

However, were this meant for production, being AWS based I would have preferences a cloud native solution for the API's, such as API Gateway with lambda integration to handle the requests. This would allow us to more scale with options such as caching on API Gateway and WAF for security.
